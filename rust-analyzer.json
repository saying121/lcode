{
  "rust-analyzer": {
    "checkOnSave": false,
    "rustfmt": {
      "extraArgs": [],
      "rangeFormatting": {
        "enable": true
      }
    },
    "check": {
      "extraArgs": ["--no-deps"],
      "command": "clippy",
      "allTargets": true,
      "invocationStrategy": "per_workspace",
      "extraEnv": [],
      "invocationLocation": "workspace"
    },
    "semanticHighlighting": {
      "operator": {
        "specialization": {
          "enable": true
        }
      },
      "punctation": {
        "enable": true,
        "specialization": {
          "enable": true
        },
        "separate": {
          "macro": {
            "bang": true
          }
        }
      },
      "strings": {
        "enable": true
      }
    },
    "notifications": {
      "cargoTomlNotFound": true
    },
    "cachePriming": {
      "enable": true,
      "num": 0
    },
    "typing": {
      "autoClosingAngleBrackets": {
        "enable": true
      }
    },
    "runnables": {
      "extraArgs": []
    },
    "procMacro": {
      "enable": true,
      "attributes": {
        "enable": true
      },
      "ignore": []
    },
    "cargo": {
      "buildScripts": {
        "invocationLocation": "workspace",
        "invocationStrategy": "per_workspace",
        "sysroot": "discover",
        "useRustcWrapper": true,
        "cfgs": [],
        "extraArgs": [],
        "extraEnv": [],
        "features": [],
        "noDefaultFeatures": false,
        "enable": true,
        "sysrootSrc": "",
        "unsetTest": ["core"]
      },
      "storeload": true
    },
    "imports": {
      "granularity": {
        "enable": true,
        "enforce": true,
        "group": "crate"
      },
      "prefer": {
        "no": {
          "std": false
        }
      },
      "prefix": "plain",
      "merge": {
        "glob": true
      },
      "group": {
        "enable": true
      }
    },
    "workspace": {
      "symbol": {
        "search": {
          "limit": 128
        }
      }
    },
    "highlightRelated": {
      "yieldPoints": {
        "enable": true
      },
      "references": {
        "enable": true
      },
      "breakPoints": {
        "enable": true
      },
      "closureCaptures": {
        "enable": true
      },
      "exitPoints": {
        "enable": true
      }
    },
    "diagnostics": {
      "warningsAsInfo": ["unused_variables"],
      "files": {
        "excludeDirs": [],
        "watcher": "client"
      },
      "remapprefix": [],
      "enable": true,
      "disabled": [],
      "experimental": {
        "enable": false
      },
      "warningsAsHint": []
    },
    "inlayHints": {
      "closureCaptureHints": {
        "enable": true
      },
      "closureReturnTypeHints": {
        "enable": "always"
      },
      "closureStyle": "impl_fn",
      "discriminantHints": {
        "enable": "always"
      },
      "expressionAdjustmentHints": {
        "enable": "always",
        "hideOutsideUnsafe": false,
        "mode": "postfix "
      },
      "typeHints": {
        "enable": true,
        "hideNamedConstructor": false,
        "hideClosureInitialization": false
      },
      "renderColons": true,
      "lifetimeElisionHints": {
        "enable": "always",
        "useParameterNames": true
      },
      "parameterHints": {
        "enable": true
      },
      "maxLength": 20,
      "bindingModeHints": {
        "enable": true
      },
      "chainingHints": {
        "enable": true
      },
      "closingBraceHints": {
        "enable": true,
        "minLines": 40
      }
    },
    "completion": {
      "autoimport": {
        "enable": true
      },
      "autoself": {
        "enable": true
      },
      "postfix": {
        "enable": true
      },
      "privateEditable": {
        "enable": true
      },
      "snippets": {
        "custom": {
          "print": {
            "prefix": "print",
            "description": "print!(…);",
            "body": ["print!(\"$1\"$2);$0"]
          },
          "Some": {
            "scope": "expr",
            "description": "Wrap the expression in an `Option::Some`",
            "body": "Some(${receiver})",
            "postfix": "some"
          },
          "writeln": {
            "prefix": "writeln",
            "description": "writeln!(…, …)",
            "body": ["writeln!(${1}, \"${2}\")"]
          },
          "eprln": {
            "scope": "expr",
            "description": "Wrap the expression in an `eprintln!`",
            "body": "eprintln!(\"{$1}\", ${receiver});$0",
            "postfix": "eprln"
          },
          "prln": {
            "scope": "expr",
            "description": "Wrap the expression in an `println!`",
            "body": "println!(\"{${1::#?}}\", ${receiver});$0",
            "postfix": "prln"
          },
          "assert_eq": {
            "prefix": "assert_eq",
            "description": "assert_eq!(…, …);",
            "body": ["assert_eq!(${1}, ${2});"]
          },
          "prvar": {
            "scope": "expr",
            "description": "Wrap the expression in an `println!`",
            "body": "println!(r##\"(| ${receiver} |) ${2:->} {${1::#?}}\"##, ${receiver});$0",
            "postfix": "prvar"
          },
          "debug_assert_eq": {
            "prefix": "debug_assert_eq",
            "description": "debug_assert_eq!(…, …)",
            "body": ["debug_assert_eq!(${1}, ${2});"]
          },
          "dbg_d": {
            "scope": "expr",
            "description": "Wrap the expression in an `println!`",
            "body": ["#[cfg(debug_assertions)]", "dbg!(${receiver});$0"],
            "postfix": "dbg_d"
          },
          "debug_assert_ne": {
            "prefix": "debug_assert_ne",
            "description": "debug_assert_ne!(…, …)",
            "body": ["debug_assert_ne!(${1}, ${2});"]
          },
          "dbgr_d": {
            "scope": "expr",
            "description": "Wrap the expression in an `println!`",
            "body": ["#[cfg(debug_assertions)]", "dbg!(&${receiver});$0"],
            "postfix": "dbgr_d"
          },
          "return": {
            "prefix": ["rt", "return"],
            "description": "return …;",
            "body": ["return $1;"],
            "scope": "expr"
          },
          "Br": {
            "scope": "expr",
            "description": "Wrap the expression in an `println!`",
            "body": ["{$1", "    ${receiver}", "$0}"],
            "postfix": "Br"
          },
          "unsafe": {
            "prefix": ["unsafe"],
            "description": "Insert a unsafe call",
            "body": ["unsafe {", "\t$1", "}$0"],
            "scope": "expr"
          },
          "inline-fn": {
            "prefix": "inline-fn",
            "description": "inlined function",
            "body": [
              "#[inline]",
              "pub fn ${1:name}() {",
              "    ${2:unimplemented!();}",
              "}"
            ]
          },
          "assert": {
            "prefix": "assert",
            "description": "assert!(…);",
            "body": ["assert!(${1});"]
          },
          "thread_spawn": {
            "prefix": ["spawn", "tspawn"],
            "body": ["thread::spawn(move || {", "\t$1", "});$0"],
            "description": "Insert a thread::spawn call",
            "scope": "expr",
            "requires": "std::thread"
          },
          "let": {
            "prefix": "letv",
            "description": "let … = …;",
            "body": ["let ${1:pat} = ${2:expr};"]
          },
          "Arc::new": {
            "requires": "std::sync::Arc",
            "body": "Arc::new(${receiver})",
            "postfix": "arc",
            "description": "Put the expression into an `Arc`",
            "scope": "expr"
          },
          "macro_use": {
            "prefix": "macro_use",
            "description": "#[macro_use(…)]",
            "body": ["#[macro_use(${1})]"]
          },
          "t_end": {
            "prefix": ["tui_restore"],
            "body": [
              "// restore terminal",
              "disable_raw_mode()?;",
              "execute!(\n    terminal.backend_mut(),\n    LeaveAlternateScreen,\n    DisableMouseCapture\n)?;\n            ",
              "terminal.show_cursor()?;"
            ],
            "description": "terminal end flow",
            "scope": "expr",
            "requires": [
              "crossterm::event::DisableMouseCapture",
              "crossterm::terminal::LeaveAlternateScreen",
              "crossterm::terminal::disable_raw_mode"
            ]
          },
          "tokio_spawn": {
            "prefix": ["tkspawn"],
            "body": ["tokio::spawn(async move {", "\t$1", "});$0"],
            "description": "Insert a tokio::spawn call",
            "scope": "expr",
            "requires": "tokio"
          },
          "t_start": {
            "prefix": ["tui_setup"],
            "body": [
              "// setup terminal",
              "let mut stdout = io::stdout();",
              "enable_raw_mode()?;",
              "execute!(stdout, EnterAlternateScreen)?;",
              "let backend = CrosstermBackend::new(stdout);",
              "let mut terminal = Terminal::new(backend)?;"
            ],
            "description": "terminal start flow",
            "scope": "expr",
            "requires": [
              "std::io",
              "crossterm::terminal::enable_raw_mode",
              "crossterm::terminal::EnterAlternateScreen",
              "crossterm::event::EnableMouseCapture",
              "ratatui::prelude::CrosstermBackend",
              "ratatui::Terminal"
            ]
          },
          "println": {
            "prefix": "println",
            "description": "println!(…);",
            "body": ["println!(\"$1\"$2);$0"]
          },
          "Arc::clone": {
            "requires": "std::sync::Arc",
            "body": "Arc::clone(&${receiver})",
            "postfix": "arc_clone",
            "description": "Put the expression into an `Arc::clone`",
            "scope": "expr"
          },
          "format_args": {
            "prefix": "format_args",
            "description": "format_args!(…)",
            "body": ["format_args!(\"${1}\"${2})"]
          },
          "letm": {
            "prefix": ["letm"],
            "description": "let mut … = …;",
            "body": ["let mut ${1:var} = $2;$0"],
            "scope": "expr"
          },
          "match_res": {
            "prefix": "match_res",
            "description": "match … { … }",
            "body": [
              "match ${1:expr} {",
              "    Ok(${2:expr}) => ${3:expr},",
              "    Err(${4:err}) => ${5:expr},",
              "}"
            ]
          },
          "Rc::new": {
            "requires": "std::rc::Rc",
            "body": "Rc::new(${receiver})",
            "postfix": "rc",
            "description": "Put the expression into an `Rc`",
            "scope": "expr"
          },
          "thread_sleep": {
            "prefix": ["sleep", "tsleep"],
            "body": ["thread::sleep($1);$0"],
            "description": "Insert a thread::sleep",
            "scope": "expr",
            "requires": "std::thread"
          },
          "option_env": {
            "prefix": "option_env",
            "description": "option_env!(\"…\")",
            "body": ["option_env!(\"${1}\")"]
          },
          "tracing": {
            "prefix": ["tracing_subscriber", "log_sub"],
            "body": [
              "tracing_subscriber::fmt()",
              ".with_max_level(tracing::Level::DEBUG)",
              ".with_test_writer()",
              ".init();"
            ],
            "description": "subscriber debug",
            "scope": "expr",
            "requires": ["tracing_subscriber", "tracing"]
          },
          "Rc::clone": {
            "requires": "std::rc::Rc",
            "body": "Rc::clone(${receiver})",
            "postfix": "rc_clone",
            "description": "Put the expression into an `Rc::clone`",
            "scope": "expr"
          },
          "panic": {
            "prefix": "panic",
            "description": "panic!(…);",
            "body": ["panic!(\"${1}\"${2});"]
          },
          "thread_local": {
            "prefix": "thread_local",
            "description": "thread_local!(static …: … = …);",
            "body": [
              "thread_local!(static ${1:STATIC}: ${2:Type} = ${4:init});"
            ]
          },
          "try": {
            "prefix": "try",
            "description": "try!(…)",
            "body": ["try!(${1})"]
          },
          "Box::pin": {
            "requires": "std::boxed::Box",
            "body": "Box::pin(${receiver})",
            "postfix": "pinbox",
            "description": "Put the expression into a pinned `Box`",
            "scope": "expr"
          },
          "format": {
            "prefix": "format",
            "description": "format!(…)",
            "body": ["format!(\"${1}\"${2})"]
          },
          "bench": {
            "prefix": "bench",
            "description": "#[bench]",
            "body": [
              "#[bench]",
              "fn ${1:name}(b: &mut test::Bencher) {",
              "    ${2:b.iter(|| ${3:/* benchmark code */})}",
              "}"
            ]
          },
          "match_opt": {
            "prefix": "match_option",
            "description": "match … { … }",
            "body": [
              "match ${1:expr} {",
              "    Some(${2:expr}) => ${3:expr},",
              "    ${4:None} => ${5:expr},",
              "}"
            ]
          },
          "tracing_appender": {
            "prefix": ["tracing_appender", "log_sub"],
            "body": [
              "let appender = rolling::never(\"some/path\", \"xxx.log\");",
              "let (non_blocking, _guard) = tracing_appender::non_blocking(appender);",
              "",
              "let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));",
              "",
              "let file_layer = fmt::layer() .with_thread_ids(true) .with_level(true) .with_ansi(false) .with_writer(non_blocking);",
              "",
              "let formatting_layer = fmt::layer() .pretty() .with_writer(std::io::stderr);",
              "",
              "Registry::default() .with(env_filter) .with(formatting_layer) .with(file_layer) .init();"
            ],
            "description": "subscriber debug",
            "scope": "expr",
            "requires": [
              "tracing_appender::rolling",
              "tracing_subscriber::fmt",
              "tracing_subscriber::prelude::__tracing_subscriber_SubscriberExt",
              "tracing_subscriber::util::SubscriberInitExt",
              "tracing_subscriber::EnvFilter",
              "tracing_subscriber::Registry"
            ]
          },
          "Err": {
            "scope": "expr",
            "description": "Wrap the expression in a `Result::Err`",
            "body": "Err(${receiver})",
            "postfix": "err"
          },
          "concat_idents": {
            "prefix": "concat_idents",
            "description": "concat_idents!(…)",
            "body": ["concat_idents!(${1})"]
          },
          "async": {
            "prefix": ["async"],
            "description": "Insert a async call",
            "body": ["async $0"],
            "scope": "expr"
          },
          "Ok": {
            "scope": "expr",
            "description": "Wrap the expression in a `Result::Ok`",
            "body": "Ok(${receiver})",
            "postfix": "ok"
          },
          "write": {
            "prefix": "write",
            "description": "write!(…)",
            "body": ["write!(${1}, \"${2}\")"]
          }
        }
      },
      "callable": {
        "snippets": "fill_arguments"
      }
    },
    "lens": {
      "debug": {
        "enable": true
      },
      "references": {
        "adt": {
          "enable": false
        },
        "enumVariant": {
          "enable": false
        },
        "method": {
          "enable": true
        },
        "trait": {
          "enable": true
        }
      },
      "enable": true,
      "location": "location",
      "forceCustomCommands": true,
      "implementations": {
        "enable": true
      }
    },
    "lru": {
      "capacity": 128
    },
    "hover": {
      "actions": {
        "enable": true
      },
      "memoryLayout": {
        "enable": true,
        "offset": "hexadecimal",
        "alignment": "hexadecimal",
        "niches": false
      }
    }
  }
}
